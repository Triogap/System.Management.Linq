/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
namespace System.Management.Types.Win32;

public partial record class VideoController(ManagementObject ManagementObject) : CIM.PCVideoController(ManagementObject)
{
    /// <summary>
    /// General chipset used for this controller to compare compatibilities with the system.
    /// </summary>
    public string? AdapterCompatibility => (string)ManagementObject[nameof(AdapterCompatibility)];
    /// <summary>
    /// Name or identifier of the digital-to-analog converter (DAC) chip. The character set of this property is alphanumeric.
    /// </summary>
    public string? AdapterDACType => (string)ManagementObject[nameof(AdapterDACType)];
    /// <summary>
    /// Memory size of the video adapter.
    /// </summary>
    public uint? AdapterRAM => (uint?)ManagementObject[nameof(AdapterRAM)];
    /// <summary>
    /// Size of the system's color table. The device must have a color depth of no more than 8 bits per pixel; otherwise, this property is not set.
    /// </summary>
    public uint? ColorTableEntries => (uint?)ManagementObject[nameof(ColorTableEntries)];
    /// <summary>
    /// Current number of device-specific pens. A value of 0xffff means that the device does not support pens.
    /// </summary>
    public uint? DeviceSpecificPens => (uint?)ManagementObject[nameof(DeviceSpecificPens)];
    /// <summary>
    /// Dither type of the video controller. The property can be one of the predefined values, or a driver-defined value greater than or equal to 256. If line art dithering is chosen, the controller uses a dithering method that produces well-defined borders between black, white, and gray scalings. Line art dithering is not suitable for images that include continuous graduations in intensity and hue such as scanned photographs.
    /// </summary>
    public uint? DitherType => (uint?)ManagementObject[nameof(DitherType)];
    /// <summary>
    /// Last modification date and time of the currently installed video driver.
    /// </summary>
    public DateTimeOffset? DriverDate => ManagementObject.GetDateTimePropertyValue(nameof(DriverDate));
    /// <summary>
    /// Version number of the video driver.
    /// </summary>
    public string? DriverVersion => (string)ManagementObject[nameof(DriverVersion)];
    /// <summary>
    /// Specific value of one of the three possible color-matching methods or intents that should be used by default. This property is used primarily for non-ICM applications. ICM applications establish intents by using the ICM functions. This property can be a predefined value or a driver defined value greater than or equal to 256. Color matching based on saturation is the most appropriate choice for business graphs when dithering is not desired. Color matching based on contrast is the most appropriate choice for scanned or photographic images when dithering is desired. Color matching optimized to match the exact color requested is most appropriate for use with business logos or other images when an exact color match is desired.
    /// </summary>
    public uint? ICMIntent => (uint?)ManagementObject[nameof(ICMIntent)];
    /// <summary>
    /// Method of handling ICM. For non-ICM applications, this property determines if ICM is enabled. For ICM applications, the system examines this property to determine how to handle ICM support. This property can be a predefined value or a driver-defined value greater than or equal to 256. The value determines which system handles image color matching.
    /// </summary>
    public uint? ICMMethod => (uint?)ManagementObject[nameof(ICMMethod)];
    /// <summary>
    /// Path to the video adapter's .inf file.
    /// </summary>
    public string? InfFilename => (string)ManagementObject[nameof(InfFilename)];
    /// <summary>
    /// Section of the .inf file where the Windows video information resides.
    /// </summary>
    public string? InfSection => (string)ManagementObject[nameof(InfSection)];
    /// <summary>
    /// Name of the installed display device driver.
    /// </summary>
    public string? InstalledDisplayDrivers => (string)ManagementObject[nameof(InstalledDisplayDrivers)];
    /// <summary>
    /// If TRUE, gray scale is used to display images.
    /// </summary>
    public bool? Monochrome => (bool?)ManagementObject[nameof(Monochrome)];
    /// <summary>
    /// Number of reserved entries in the system palette. The operating system may reserve entries to support standard colors for task bars and other desktop display items. This index is valid only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index, and is available only if the driver is compatible with 16-bit Windows. If the system is not using a palette, ReservedSystemPaletteEntries is not set.
    /// </summary>
    public uint? ReservedSystemPaletteEntries => (uint?)ManagementObject[nameof(ReservedSystemPaletteEntries)];
    /// <summary>
    /// Version number of the initialization data specification (upon which the structure is based).
    /// </summary>
    public uint? SpecificationVersion => (uint?)ManagementObject[nameof(SpecificationVersion)];
    /// <summary>
    /// Current number of color index entries in the system palette. This index is valid only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index, and is available only if the driver is compatible with 16-bit Windows. If the system is not using a palette, SystemPaletteEntries is not set.
    /// </summary>
    public uint? SystemPaletteEntries => (uint?)ManagementObject[nameof(SystemPaletteEntries)];
    /// <summary>
    /// Current resolution, color, and scan mode settings of the video controller.
    /// </summary>
    public string? VideoModeDescription => (string)ManagementObject[nameof(VideoModeDescription)];
}
