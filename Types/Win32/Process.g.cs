/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
#nullable enable
namespace System.Management.Types.Win32;

public partial record class Process(ManagementObject ManagementObject) : CIM.Process(ManagementObject)
{
    /// <summary>
    /// Command line used to start a specific process, if applicable.
    /// </summary>
    public string? CommandLine => (string)ManagementObject[nameof(CommandLine)];
    /// <summary>
    /// Path to the executable file of the process.
    /// </summary>
    public string? ExecutablePath => (string)ManagementObject[nameof(ExecutablePath)];
    /// <summary>
    /// Total number of open handles owned by the process. HandleCount is the sum of the handles currently open by each thread in this process. A handle is used to examine or modify the system resources. Each handle has an entry in a table that is maintained internally. Entries contain the addresses of the resources and data to identify the resource type.
    /// </summary>
    public uint? HandleCount => (uint?)ManagementObject[nameof(HandleCount)];
    /// <summary>
    /// Time in kernel mode, in milliseconds. If this information is not available, use a value of 0 (zero).
    /// </summary>
    public new ulong? KernelModeTime => (ulong?)ManagementObject[nameof(KernelModeTime)];
    /// <summary>
    /// Maximum working set size of the process. The working set of a process is the set of memory pages visible to the process in physical RAM. These pages are resident, and available for an application to use without triggering a page fault.
    /// </summary>
    public uint? MaximumWorkingSetSize => (uint?)ManagementObject[nameof(MaximumWorkingSetSize)];
    /// <summary>
    /// Minimum working set size of the process. The working set of a process is the set of memory pages visible to the process in physical RAM. These pages are resident and available for an application to use without triggering a page fault.
    /// </summary>
    public uint? MinimumWorkingSetSize => (uint?)ManagementObject[nameof(MinimumWorkingSetSize)];
    /// <summary>
    /// Number of I/O operations performed that are not read or write operations.
    /// </summary>
    public ulong? OtherOperationCount => (ulong?)ManagementObject[nameof(OtherOperationCount)];
    /// <summary>
    /// Amount of data transferred during operations that are not read or write operations.
    /// </summary>
    public ulong? OtherTransferCount => (ulong?)ManagementObject[nameof(OtherTransferCount)];
    /// <summary>
    /// Number of page faults that a process generates.
    /// </summary>
    public uint? PageFaults => (uint?)ManagementObject[nameof(PageFaults)];
    /// <summary>
    /// Amount of page file space that a process is using currently. This value is consistent with the VMSize value in TaskMgr.exe.
    /// </summary>
    public uint? PageFileUsage => (uint?)ManagementObject[nameof(PageFileUsage)];
    /// <summary>
    /// Unique identifier of the process that creates a process. Process identifier numbers are reused, so they only identify a process for the lifetime of that process. It is possible that the process identified by ParentProcessId is terminated, so ParentProcessId may not refer to a running process. It is also possible that ParentProcessId incorrectly refers to a process that reuses a process identifier. You can use the CreationDate property to determine whether the specified parent was created after the process represented by this Win32_Process instance was created.
    /// </summary>
    public uint? ParentProcessId => (uint?)ManagementObject[nameof(ParentProcessId)];
    /// <summary>
    /// Maximum amount of page file space used during the life of a process.
    /// </summary>
    public uint? PeakPageFileUsage => (uint?)ManagementObject[nameof(PeakPageFileUsage)];
    /// <summary>
    /// Maximum virtual address space a process uses at any one time. Using virtual address space does not necessarily imply corresponding use of either disk or main memory pages. However, virtual space is finite, and by using too much the process might not be able to load libraries.
    /// </summary>
    public ulong? PeakVirtualSize => (ulong?)ManagementObject[nameof(PeakVirtualSize)];
    /// <summary>
    /// Peak working set size of a process.
    /// </summary>
    public uint? PeakWorkingSetSize => (uint?)ManagementObject[nameof(PeakWorkingSetSize)];
    /// <summary>
    /// Scheduling priority of a process within an operating system. The higher the value, the higher priority a process receives. Priority values can range from 0 (zero), which is the lowest priority to 31, which is highest priority.
    /// </summary>
    public new uint? Priority => (uint?)ManagementObject[nameof(Priority)];
    /// <summary>
    /// Current number of pages allocated that are only accessible to the process represented by this Win32_Process instance.
    /// </summary>
    public ulong? PrivatePageCount => (ulong?)ManagementObject[nameof(PrivatePageCount)];
    /// <summary>
    /// Numeric identifier used to distinguish one process from another. ProcessIDs are valid from process creation time to process termination. Upon termination, that same numeric identifier can be applied to a new process.
    /// </summary>
    public uint? ProcessId => (uint?)ManagementObject[nameof(ProcessId)];
    /// <summary>
    /// Quota amount of nonpaged pool usage for a process.
    /// </summary>
    public uint? QuotaNonPagedPoolUsage => (uint?)ManagementObject[nameof(QuotaNonPagedPoolUsage)];
    /// <summary>
    /// Quota amount of paged pool usage for a process.
    /// </summary>
    public uint? QuotaPagedPoolUsage => (uint?)ManagementObject[nameof(QuotaPagedPoolUsage)];
    /// <summary>
    /// Peak quota amount of nonpaged pool usage for a process.
    /// </summary>
    public uint? QuotaPeakNonPagedPoolUsage => (uint?)ManagementObject[nameof(QuotaPeakNonPagedPoolUsage)];
    /// <summary>
    /// Peak quota amount of paged pool usage for a process.
    /// </summary>
    public uint? QuotaPeakPagedPoolUsage => (uint?)ManagementObject[nameof(QuotaPeakPagedPoolUsage)];
    /// <summary>
    /// Number of read operations performed.
    /// </summary>
    public ulong? ReadOperationCount => (ulong?)ManagementObject[nameof(ReadOperationCount)];
    /// <summary>
    /// Amount of data read.
    /// </summary>
    public ulong? ReadTransferCount => (ulong?)ManagementObject[nameof(ReadTransferCount)];
    /// <summary>
    /// Unique identifier that an operating system generates when a session is created. A session spans a period of time from logon until logoff from a specific system.
    /// </summary>
    public uint? SessionId => (uint?)ManagementObject[nameof(SessionId)];
    /// <summary>
    /// Number of active threads in a process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes an instruction. Each running process has at least one thread.
    /// </summary>
    public uint? ThreadCount => (uint?)ManagementObject[nameof(ThreadCount)];
    /// <summary>
    /// Time in user mode, in 100 nanosecond units. If this information is not available, use a value of 0 (zero).
    /// </summary>
    public new ulong? UserModeTime => (ulong?)ManagementObject[nameof(UserModeTime)];
    /// <summary>
    /// Current size of the virtual address space that a process is using, not the physical or virtual memory actually used by the process. Using virtual address space does not necessarily imply corresponding use of either disk or main memory pages. Virtual space is finite, and by using too much, the process might not be able to load libraries. This value is consistent with what you see in Perfmon.exe.
    /// </summary>
    public ulong? VirtualSize => (ulong?)ManagementObject[nameof(VirtualSize)];
    /// <summary>
    /// Version of Windows in which the process is running.
    /// </summary>
    public string? WindowsVersion => (string)ManagementObject[nameof(WindowsVersion)];
    /// <summary>
    /// Number of write operations performed.
    /// </summary>
    public ulong? WriteOperationCount => (ulong?)ManagementObject[nameof(WriteOperationCount)];
    /// <summary>
    /// Amount of data written.
    /// </summary>
    public ulong? WriteTransferCount => (ulong?)ManagementObject[nameof(WriteTransferCount)];
}
