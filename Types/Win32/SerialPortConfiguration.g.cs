/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
#nullable enable
namespace System.Management.Types.Win32;

public partial record class SerialPortConfiguration(ManagementObject ManagementObject) : CIM.Setting(ManagementObject)
{
    /// <summary>
    /// If TRUE, read and write operations are terminated if an error occurs. If TRUE, the driver terminates all read and write operations with an error status if an error occurs. The driver will not accept any further communications operations until the application acknowledges the error.
    /// </summary>
    public bool? AbortReadWriteOnError => (bool?)ManagementObject[nameof(AbortReadWriteOnError)];
    /// <summary>
    /// Baud (bits per second) rate at which the communications device operates.
    /// </summary>
    public uint? BaudRate => (uint?)ManagementObject[nameof(BaudRate)];
    /// <summary>
    /// If TRUE, binary-mode data transfers are enabled for the serial port. Computer systems running Windows only allow binary transfers through serial ports, so this value is always TRUE.
    /// </summary>
    public bool? BinaryModeEnabled => (bool?)ManagementObject[nameof(BinaryModeEnabled)];
    /// <summary>
    /// Number of bits transmitted and received for each byte of data for the Windows serial port. The number may vary with control and error correction bits, such as parity bits.
    /// </summary>
    public uint? BitsPerByte => (uint?)ManagementObject[nameof(BitsPerByte)];
    /// <summary>
    /// If TRUE, data transmissions continue when the input buffer has come within XOffXMitThreshold bytes of being full and the driver has transmitted the XOffChararcter value to stop receiving bytes. If FALSE, transmission does not continue until the input buffer is within XOnXMitThreshold bytes of being empty and the driver has transmitted the XOnCharacter value to resume reception.
    /// </summary>
    public bool? ContinueXMitOnXOff => (bool?)ManagementObject[nameof(ContinueXMitOnXOff)];
    /// <summary>
    /// If TRUE, the clear to send (CTS) signal is checked before transmitting data. CTS signals that both devices on the serial connection are ready to transfer data. Data transmission is suspended until the CTS signal is given.
    /// </summary>
    public bool? CTSOutflowControl => (bool?)ManagementObject[nameof(CTSOutflowControl)];
    /// <summary>
    /// If TRUE, NULL bytes (characters) are discarded when they are received.
    /// </summary>
    public bool? DiscardNULLBytes => (bool?)ManagementObject[nameof(DiscardNULLBytes)];
    /// <summary>
    /// If TRUE, data outflow control is enabled when there is a data set ready (DSR) condition. DSR signals that the connection has been established by the devices on the serial connection. DSR data transmission is suspended until the DSR signal is given.
    /// </summary>
    public bool? DSROutflowControl => (bool?)ManagementObject[nameof(DSROutflowControl)];
    /// <summary>
    /// If TRUE, the communications driver is sensitive to the state of the DSR signal. The driver ignores any bytes received, unless the DSR modem input line is high.
    /// </summary>
    public bool? DSRSensitivity => (bool?)ManagementObject[nameof(DSRSensitivity)];
    /// <summary>
    /// Use of the data terminal ready (DTR) flow control after a connection has been established.
    /// </summary>
    public string? DTRFlowControlType => (string)ManagementObject[nameof(DTRFlowControlType)];
    /// <summary>
    /// Value of the character used to signal the end of data.
    /// </summary>
    public uint? EOFCharacter => (uint?)ManagementObject[nameof(EOFCharacter)];
    /// <summary>
    /// Value of the character used to replace bytes received with a parity error.
    /// </summary>
    public uint? ErrorReplaceCharacter => (uint?)ManagementObject[nameof(ErrorReplaceCharacter)];
    /// <summary>
    /// If TRUE, bytes received with parity errors are replaced with the ErrorReplaceCharacter value. Characters with parity errors are only replaced if this property is TRUE and the parity is enabled.
    /// </summary>
    public bool? ErrorReplacementEnabled => (bool?)ManagementObject[nameof(ErrorReplacementEnabled)];
    /// <summary>
    /// Value of the control character that is used to signal an event, such as end of file.
    /// </summary>
    public uint? EventCharacter => (uint?)ManagementObject[nameof(EventCharacter)];
    /// <summary>
    /// If TRUE, the serial port is busy.
    /// </summary>
    public bool? IsBusy => (bool?)ManagementObject[nameof(IsBusy)];
    /// <summary>
    /// Name of the Windows serial port.
    /// </summary>
    public string? Name => (string)ManagementObject[nameof(Name)];
    /// <summary>
    /// Method of parity checking to be used. Parity is used as an error checking technique where an extra parity bit is included with every unit of data. The receiver can then verify the validity of the data by counting the bits that are set.
    /// </summary>
    public string? Parity => (string)ManagementObject[nameof(Parity)];
    /// <summary>
    /// If TRUE, parity checking is enabled.
    /// </summary>
    public bool? ParityCheckEnabled => (bool?)ManagementObject[nameof(ParityCheckEnabled)];
    /// <summary>
    /// Request to send (RTS) flow control. RTS is used to signal that data is available for transmission.
    /// </summary>
    public string? RTSFlowControlType => (string)ManagementObject[nameof(RTSFlowControlType)];
    /// <summary>
    /// Number of stop bits to be used. Stop bits separate each unit of data on an asynchronous serial connection. They are also sent continuously when no data is available for transmission.
    /// </summary>
    public string? StopBits => (string)ManagementObject[nameof(StopBits)];
    /// <summary>
    /// Value of the XOFF character for both transmission and reception. XOFF is a software control to stop the transmission of data (whereas RTS and CTS are hardware controls). XON resumes the transmission.
    /// </summary>
    public uint? XOffCharacter => (uint?)ManagementObject[nameof(XOffCharacter)];
    /// <summary>
    /// Maximum number of bytes allowed in the input buffer before the XOFF character is sent.
    /// </summary>
    public uint? XOffXMitThreshold => (uint?)ManagementObject[nameof(XOffXMitThreshold)];
    /// <summary>
    /// Value of the XON character for both transmission and reception. XON is a software control to resume the transmission of data (whereas RTS and CTS are hardware controls). XOFF stops the transmission.
    /// </summary>
    public uint? XOnCharacter => (uint?)ManagementObject[nameof(XOnCharacter)];
    /// <summary>
    /// Minimum number of bytes allowed in the input buffer before the XON character is sent. This property works in conjunction with XOffXMitThreshold to regulate the rate at which data is transferred.
    /// </summary>
    public uint? XOnXMitThreshold => (uint?)ManagementObject[nameof(XOnXMitThreshold)];
    /// <summary>
    /// If TRUE, XON/XOFF flow control is used during reception. If TRUE, the XOffCharacter value is sent when the input buffer comes within XOffXMitThreshold bytes of being full, and the XOnCharacter value is sent when the input buffer comes within XOnXMitThreshold bytes of being empty.
    /// </summary>
    public uint? XOnXOffInFlowControl => (uint?)ManagementObject[nameof(XOnXOffInFlowControl)];
    /// <summary>
    /// The XOnXOffOutFlowControl specifies whether XON or XOFF flow control is used during transmission. If TRUE, transmission stops when the XOffCharacter value is received and starts again when the XOnCharacter value is received.
    /// </summary>
    public uint? XOnXOffOutFlowControl => (uint?)ManagementObject[nameof(XOnXOffOutFlowControl)];
}
