/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
#nullable enable
namespace System.Management.Types.Win32;

public partial record class NetworkAdapterConfiguration(ManagementObject ManagementObject) : CIM.Setting(ManagementObject)
{
    /// <summary>
    /// If TRUE, TCP/IP transmits Address Resolution Protocol (ARP) queries with source routing enabled on Token Ring networks. By default (FALSE), ARP first queries without source routing, and then retries with source routing enabled if no reply is received. Source routing allows the routing of network packets across different types of networks.
    /// </summary>
    public bool? ArpAlwaysSourceRoute => (bool?)ManagementObject[nameof(ArpAlwaysSourceRoute)];
    /// <summary>
    /// If TRUE, Ethernet packets follow the IEEE 802.3 Sub-Network Access Protocol (SNAP) encoding. Setting this parameter to 1 forces TCP/IP to transmit Ethernet packets by using 802.3 SNAP encoding. By default (FALSE), the stack transmits packets in DIX Ethernet format.
    /// </summary>
    public bool? ArpUseEtherSNAP => (bool?)ManagementObject[nameof(ArpUseEtherSNAP)];
    /// <summary>
    /// Valid Windows file path to standard Internet database files (HOSTS, LMHOSTS, NETWORKS, and PROTOCOLS). The file path is used by the Windows Sockets interface.
    /// </summary>
    public string? DatabasePath => (string)ManagementObject[nameof(DatabasePath)];
    /// <summary>
    /// If TRUE, dead gateway detection occurs. With this feature enabled, Transmission Control Protocol (TCP) asks Internet Protocol (IP) to change to a backup gateway if it retransmits a segment several times without receiving a response.
    /// </summary>
    public bool? DeadGWDetectEnabled => (bool?)ManagementObject[nameof(DeadGWDetectEnabled)];
    /// <summary>
    /// Array of IP addresses of default gateways that the computer system uses.
    /// </summary>
    public string[]? DefaultIPGateway => (string[])ManagementObject[nameof(DefaultIPGateway)];
    public byte? DefaultTOS => (byte?)ManagementObject[nameof(DefaultTOS)];
    public byte? DefaultTTL => (byte?)ManagementObject[nameof(DefaultTTL)];
    /// <summary>
    /// If TRUE, the dynamic host configuration protocol (DHCP) server automatically assigns an IP address to the computer system when establishing a network connection.
    /// </summary>
    public bool? DHCPEnabled => (bool?)ManagementObject[nameof(DHCPEnabled)];
    /// <summary>
    /// Expiration date and time for a leased IP address that was assigned to the computer by the dynamic host configuration protocol (DHCP) server.
    /// </summary>
    public DateTimeOffset? DHCPLeaseExpires => ManagementObject.GetDateTimePropertyValue(nameof(DHCPLeaseExpires));
    /// <summary>
    /// Date and time the lease was obtained for the IP address assigned to the computer by the dynamic host configuration protocol (DHCP) server.
    /// </summary>
    public DateTimeOffset? DHCPLeaseObtained => ManagementObject.GetDateTimePropertyValue(nameof(DHCPLeaseObtained));
    /// <summary>
    /// IP address of the dynamic host configuration protocol (DHCP) server.
    /// </summary>
    public string? DHCPServer => (string)ManagementObject[nameof(DHCPServer)];
    /// <summary>
    /// Organization name followed by a period and an extension that indicates the type of organization, such as "microsoft.com". The name can be any combination of the letters A through Z, the numerals 0 through 9, and the hyphen (-), plus the period (.) character used as a separator.
    /// </summary>
    public string? DNSDomain => (string)ManagementObject[nameof(DNSDomain)];
    /// <summary>
    /// Array of DNS domain suffixes to be appended to the end of host names during name resolution. When attempting to resolve a fully qualified domain name (FQDN) from a host-only name, the system will first append the local domain name. If this is not successful, the system will use the domain suffix list to create additional FQDNs in the order listed and query DNS servers for each.
    /// </summary>
    public string[]? DNSDomainSuffixSearchOrder => (string[])ManagementObject[nameof(DNSDomainSuffixSearchOrder)];
    /// <summary>
    /// If TRUE, the Domain Name System (DNS) is enabled for name resolution over Windows Internet Naming Service (WINS) resolution. If the name cannot be resolved using DNS, the name request is forwarded to WINS for resolution.
    /// </summary>
    public bool? DNSEnabledForWINSResolution => (bool?)ManagementObject[nameof(DNSEnabledForWINSResolution)];
    /// <summary>
    /// Host name used to identify the local computer for authentication by some utilities. Other TCP/IP-based utilities can use this value to acquire the name of the local computer. Host names are stored on DNS servers in a table that maps names to IP addresses for use by DNS. The name can be any combination of the letters A through Z, the numerals 0 through 9, and the hyphen (-), plus the period (.) character used as a separator. By default, this value is the Microsoft networking computer name, but the network administrator can assign another host name without affecting the computer name.
    /// </summary>
    public string? DNSHostName => (string)ManagementObject[nameof(DNSHostName)];
    /// <summary>
    /// Array of server IP addresses to be used in querying for DNS servers.
    /// </summary>
    public string[]? DNSServerSearchOrder => (string[])ManagementObject[nameof(DNSServerSearchOrder)];
    /// <summary>
    /// If TRUE, the IP addresses for this connection are registered in DNS under the domain name of this connection in addition to being registered under the computer's full DNS name. The domain name of this connection is either set using the SetDNSDomain() method or assigned by DSCP. The registered name is the host name of the computer with the domain name appended.
    /// </summary>
    public bool? DomainDNSRegistrationEnabled => (bool?)ManagementObject[nameof(DomainDNSRegistrationEnabled)];
    public uint? ForwardBufferMemory => (uint?)ManagementObject[nameof(ForwardBufferMemory)];
    /// <summary>
    /// If TRUE, the IP addresses for this connection are registered in DNS under the computer's full DNS name. The full DNS name of the computer is displayed on the Network Identification tab in the System application in Control Panel.
    /// </summary>
    public bool? FullDNSRegistrationEnabled => (bool?)ManagementObject[nameof(FullDNSRegistrationEnabled)];
    /// <summary>
    /// Array of integer cost metric values (ranging from 1 to 9999) to be used in calculating the fastest, most reliable, or least resource-intensive routes. This argument has a one-to-one correspondence with the DefaultIPGateway property.
    /// </summary>
    public ushort[]? GatewayCostMetric => (ushort[])ManagementObject[nameof(GatewayCostMetric)];
    /// <summary>
    /// Extent to which the system supports IP multicast and participates in the Internet Group Management Protocol (IGMP). At level 0 (zero), the system provides no multicast support. At level 1, the system may only send IP multicast packets. At level 2, the system may send IP multicast packets and fully participate in IGMP to receive multicast packets.
    /// </summary>
    public byte? IGMPLevel => (byte?)ManagementObject[nameof(IGMPLevel)];
    /// <summary>
    /// Index number of the Windows network adapter configuration. The index number is used when there is more than one configuration available.
    /// </summary>
    public uint? Index => (uint?)ManagementObject[nameof(Index)];
    /// <summary>
    /// Index value that uniquely identifies a local network interface. The value in this property is the same as the value in the InterfaceIndex property in the instance of Win32_IP4RouteTable that represents the network interface in the route table.
    /// </summary>
    public uint? InterfaceIndex => (uint?)ManagementObject[nameof(InterfaceIndex)];
    /// <summary>
    /// Array of all of the IP addresses associated with the current network adapter. This property can contain either IPv6 addresses or IPv4 addresses. For more information, see IPv6 and IPv4 Support in WMI.
    /// </summary>
    public string[]? IPAddress => (string[])ManagementObject[nameof(IPAddress)];
    /// <summary>
    /// Cost of using the configured routes for the IP bound adapter and is the weighted value for those routes in the IP routing table. If there are multiple routes to a destination in the IP routing table, the route with the lowest metric is used. The default value is 1.
    /// </summary>
    public uint? IPConnectionMetric => (uint?)ManagementObject[nameof(IPConnectionMetric)];
    /// <summary>
    /// If TRUE, TCP/IP is bound and enabled on this network adapter.
    /// </summary>
    public bool? IPEnabled => (bool?)ManagementObject[nameof(IPEnabled)];
    /// <summary>
    /// If TRUE, IP port security is enabled globally across all IP-bound network adapters and the security values associated with individual network adapters are in effect. This property is used in conjunction with IPSecPermitTCPPorts, IPSecPermitUDPPorts, and IPSecPermitIPProtocols. If FALSE, IP filter security is disabled across all network adapters and allows all port and protocol traffic to flow unfiltered.
    /// </summary>
    public bool? IPFilterSecurityEnabled => (bool?)ManagementObject[nameof(IPFilterSecurityEnabled)];
    /// <summary>
    /// If TRUE, IP port security is enabled globally across all IP-bound network adapters. This property is obsolete. In place of this property, you should use IPFilterSecurityEnabled.
    /// </summary>
    public bool? IPPortSecurityEnabled => (bool?)ManagementObject[nameof(IPPortSecurityEnabled)];
    /// <summary>
    /// Array of the protocols permitted to run over the IP. The list of protocols is defined using the EnableIPSec method. The list will either be empty or contain numeric values. A numeric value of 0 (zero) indicates access permission is granted for all protocols. An empty string indicates that no protocols are permitted to run when IPFilterSecurityEnabled is TRUE.
    /// </summary>
    public string[]? IPSecPermitIPProtocols => (string[])ManagementObject[nameof(IPSecPermitIPProtocols)];
    /// <summary>
    /// Array of the ports that will be granted access permission for TCP. The list of protocols is defined using the EnableIPSec method. The list will either be empty or contain numeric values. A numeric value of 0 (zero)indicates access permission is granted for all ports. An empty string indicates that no ports are granted access permission when IPFilterSecurityEnabled is TRUE.
    /// </summary>
    public string[]? IPSecPermitTCPPorts => (string[])ManagementObject[nameof(IPSecPermitTCPPorts)];
    /// <summary>
    /// Array of the ports that will be granted User Datagram Protocol (UDP) access permission. The list of protocols is defined using the EnableIPSec method. The list will either be empty or contain numeric values. A numeric value of 0 (zero) indicates access permission is granted for all ports. An empty string indicates that no ports are granted access permission when IPFilterSecurityEnabled is TRUE.
    /// </summary>
    public string[]? IPSecPermitUDPPorts => (string[])ManagementObject[nameof(IPSecPermitUDPPorts)];
    /// <summary>
    /// Array of all of the subnet masks associated with the current network adapter.
    /// </summary>
    public string[]? IPSubnet => (string[])ManagementObject[nameof(IPSubnet)];
    /// <summary>
    /// If TRUE, IP zeros-broadcasts are used (0.0.0.0), and the system uses ones-broadcasts (255.255.255.255). Computer systems generally use ones-broadcasts, but those derived from BSD implementations use zeros-broadcasts. Systems that do not use that same broadcasts will not interoperate on the same network. The default is FALSE.
    /// </summary>
    public bool? IPUseZeroBroadcast => (bool?)ManagementObject[nameof(IPUseZeroBroadcast)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public string? IPXAddress => (string)ManagementObject[nameof(IPXAddress)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public bool? IPXEnabled => (bool?)ManagementObject[nameof(IPXEnabled)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public uint[]? IPXFrameType => (uint[])ManagementObject[nameof(IPXFrameType)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public uint? IPXMediaType => (uint?)ManagementObject[nameof(IPXMediaType)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public string[]? IPXNetworkNumber => (string[])ManagementObject[nameof(IPXNetworkNumber)];
    /// <summary>
    /// The Internetwork Packet Exchange (IPX) technology is no longer supported and this property does not contain useful data.
    /// </summary>
    public string? IPXVirtualNetNumber => (string)ManagementObject[nameof(IPXVirtualNetNumber)];
    public uint? KeepAliveInterval => (uint?)ManagementObject[nameof(KeepAliveInterval)];
    public uint? KeepAliveTime => (uint?)ManagementObject[nameof(KeepAliveTime)];
    /// <summary>
    /// Media Access Control (MAC) address of the network adapter. A MAC address is assigned by the manufacturer to uniquely identify the network adapter.
    /// </summary>
    public string? MACAddress => (string)ManagementObject[nameof(MACAddress)];
    /// <summary>
    /// Overrides the default Maximum Transmission Unit (MTU) for a network interface. The MTU is the maximum packet size (including the transport header) that the transport will transmit over the underlying network. The IP datagram can span multiple packets. The range of this value spans the minimum packet size (68) to the MTU supported by the underlying network.
    /// </summary>
    public uint? MTU => (uint?)ManagementObject[nameof(MTU)];
    public uint? NumForwardPackets => (uint?)ManagementObject[nameof(NumForwardPackets)];
    /// <summary>
    /// If TRUE, detection of black hole routers occurs while TCP discovers the path of the Maximum Transmission Unit. A black hole router does not return ICMP Destination Unreachable messages when it needs to fragment an IP datagram with the Don't Fragment bit set. TCP depends on receiving these messages to perform Path MTU Discovery. With this feature enabled, TCP will try to send segments without the Don't Fragment bit set if several retransmissions of a segment go unacknowledged. If the segment is acknowledged as a result, the MSS will be decreased and the Don't Fragment bit will be set in future packets on the connection. Enabling black hole detection increases the maximum number of retransmissions performed for a given segment. The default value of this property is FALSE.
    /// </summary>
    public bool? PMTUBHDetectEnabled => (bool?)ManagementObject[nameof(PMTUBHDetectEnabled)];
    /// <summary>
    /// If TRUE, the Maximum Transmission Unit (MTU) path is discovered over the path to a remote host. By discovering the MTU path and limiting TCP segments to this size, TCP can eliminate fragmentation at routers along the path that connect networks with different MTUs. Fragmentation adversely affects TCP throughput and network congestion. Setting this parameter to FALSE causes an MTU of 576 bytes to be used for all connections that are not to machines on the local subnet. The default is TRUE.
    /// </summary>
    public bool? PMTUDiscoveryEnabled => (bool?)ManagementObject[nameof(PMTUDiscoveryEnabled)];
    /// <summary>
    /// Service name of the network adapter. This name is usually shorter than the full product name.
    /// </summary>
    public string? ServiceName => (string)ManagementObject[nameof(ServiceName)];
    /// <summary>
    /// Bitmap of the possible settings related to NetBIOS over TCP/IP. Values are identified in the following list.
    /// </summary>
    public uint? TcpipNetbiosOptions => (uint?)ManagementObject[nameof(TcpipNetbiosOptions)];
    public uint? TcpMaxConnectRetransmissions => (uint?)ManagementObject[nameof(TcpMaxConnectRetransmissions)];
    public uint? TcpMaxDataRetransmissions => (uint?)ManagementObject[nameof(TcpMaxDataRetransmissions)];
    public uint? TcpNumConnections => (uint?)ManagementObject[nameof(TcpNumConnections)];
    /// <summary>
    /// If TRUE, TCP uses the RFC 1122 specification for urgent data. If FALSE (default), TCP uses the mode used by Berkeley Software Design (BSD) derived systems. The two mechanisms interpret the urgent pointer differently and are not interoperable. The default value is FALSE.
    /// </summary>
    public bool? TcpUseRFC1122UrgentPointer => (bool?)ManagementObject[nameof(TcpUseRFC1122UrgentPointer)];
    /// <summary>
    /// Note
    /// </summary>
    public ushort? TcpWindowSize => (ushort?)ManagementObject[nameof(TcpWindowSize)];
    /// <summary>
    /// If TRUE, local lookup files are used. Lookup files will contain a map of IP addresses to host names. If they exist on the local system, they will be found in %SystemRoot%\system32\drivers\etc.
    /// </summary>
    public bool? WINSEnableLMHostsLookup => (bool?)ManagementObject[nameof(WINSEnableLMHostsLookup)];
    /// <summary>
    /// Path to a WINS lookup file on the local system. This file will contain a map of IP addresses to host names. If the file specified in this property is found, it will be copied to the %SystemRoot%\system32\drivers\etc folder of the local system. Valid only if the WINSEnableLMHostsLookup property is TRUE.
    /// </summary>
    public string? WINSHostLookupFile => (string)ManagementObject[nameof(WINSHostLookupFile)];
    /// <summary>
    /// IP address for the primary WINS server.
    /// </summary>
    public string? WINSPrimaryServer => (string)ManagementObject[nameof(WINSPrimaryServer)];
    /// <summary>
    /// Value appended to the end of the NetBIOS name that isolates a group of computer systems communicating with only each other. It is used for all NetBIOS transactions over TCP/IP communications from that computer system. Computers configured with identical scope identifiers are able to communicate with this computer. TCP/IP clients with different scope identifiers disregard packets from computers with this scope identifier. Valid only when the EnableWINS method executes successfully.
    /// </summary>
    public string? WINSScopeID => (string)ManagementObject[nameof(WINSScopeID)];
    /// <summary>
    /// IP address for the secondary WINS server.
    /// </summary>
    public string? WINSSecondaryServer => (string)ManagementObject[nameof(WINSSecondaryServer)];
}
