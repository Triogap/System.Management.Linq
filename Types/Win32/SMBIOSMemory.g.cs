/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
#nullable enable
namespace System.Management.Types.Win32;

public partial record class SMBIOSMemory(ManagementObject ManagementObject) : Base._Object(ManagementObject)
{
    /// <summary>
    /// Array of octets that hold additional error information. An example is Error Checking and Correcting (ECC) Syndrome, or the return of the check bits if a CRC-based error methodology is used. In the latter case, if a single bit error is recognized and the cyclical redundancy check (CRC) algorithm is known, it is possible to determine the exact bit that failed. This type of data (ECC Syndrome, Check Bit or Parity Bit data, or other vendor supplied information) is included in this field. If the ErrorInfo property is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public byte[]? AdditionalErrorData => (byte[])ManagementObject[nameof(AdditionalErrorData)];
    /// <summary>
    /// If TRUE, the most recent error was correctable. If the ErrorInfo property is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public bool? CorrectableError => (bool?)ManagementObject[nameof(CorrectableError)];
    /// <summary>
    /// Ending address, referenced by an application or operating system and mapped by a memory controller for this memory object. The ending address is specified in kilobytes.
    /// </summary>
    public ulong? EndingAddress => (ulong?)ManagementObject[nameof(EndingAddress)];
    /// <summary>
    /// Memory access operation that caused the last error. The type of error is described by the ErrorInfo property. If ErrorInfo is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public ushort? ErrorAccess => (ushort?)ManagementObject[nameof(ErrorAccess)];
    /// <summary>
    /// Address of the last memory error. The type of error is described by the ErrorInfo property. If ErrorInfo is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public ulong? ErrorAddress => (ulong?)ManagementObject[nameof(ErrorAddress)];
    /// <summary>
    /// Array of data captured during the last erroneous memory access. The data occupies the first n octets of the array necessary to hold the number of bits specified by the ErrorTransferSize property. If ErrorTransferSize is 0 (zero), then this property has no meaning.
    /// </summary>
    public byte[]? ErrorData => (byte[])ManagementObject[nameof(ErrorData)];
    /// <summary>
    /// Ordering for data stored in the ErrorData property. If ErrorTransferSize is 0 (zero), then this property has no meaning.
    /// </summary>
    public ushort? ErrorDataOrder => (ushort?)ManagementObject[nameof(ErrorDataOrder)];
    /// <summary>
    /// Type of error that occurred most recently. The values 12 through 14 are unused. The ability to be corrected is indicated in the property CorrectableError.
    /// </summary>
    public ushort? ErrorInfo => (ushort?)ManagementObject[nameof(ErrorInfo)];
    /// <summary>
    /// Range, in bytes, to which the last error can be resolved. For example, if error addresses are resolved to bit 11 (that is, on a typical page basis), then errors can be resolved to 4 KB boundaries and this property is set to 4000. If the ErrorInfo property is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public ulong? ErrorResolution => (ulong?)ManagementObject[nameof(ErrorResolution)];
    /// <summary>
    /// Time that the last memory error occurred. The type of error is described by the ErrorInfo property. If the ErrorInfo property is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public DateTimeOffset? ErrorTime => ManagementObject.GetDateTimePropertyValue(nameof(ErrorTime));
    /// <summary>
    /// Size of the data transfer in bits that caused the last errorâ€”0 (zero) indicates no error. If the ErrorInfo property is equal to 3 (OK), then this property should be set to 0 (zero).
    /// </summary>
    public uint? ErrorTransferSize => (uint?)ManagementObject[nameof(ErrorTransferSize)];
    /// <summary>
    /// Free-form string that provides more information if the ErrorType property is set to 1; otherwise, this string has no meaning.
    /// </summary>
    public string? OtherErrorDescription => (string)ManagementObject[nameof(OtherErrorDescription)];
    /// <summary>
    /// Beginning address that is referenced by an application or operating system, and mapped by a memory controller for this memory object. The starting address is specified in kilobytes.
    /// </summary>
    public ulong? StartingAddress => (ulong?)ManagementObject[nameof(StartingAddress)];
    /// <summary>
    /// If TRUE, the address information in the ErrorAddress property is a system-level address. If FALSE, it is a physical address. If the ErrorInfo property is equal to 3 (OK), then this property has no meaning.
    /// </summary>
    public bool? SystemLevelAddress => (bool?)ManagementObject[nameof(SystemLevelAddress)];
}
