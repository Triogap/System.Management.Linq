/**************************************************************
 *                                                            *
 *   WARNING: This file is autogenerated by                   *
 *   System.Management.Generator.                             *
 *   Any changes made to this file will be overwritten.       *
 *                                                            *
 **************************************************************/
#nullable enable
namespace System.Management.Types.CIM;

public partial record class Memory(ManagementObject ManagementObject) : StorageExtent(ManagementObject)
{
    /// <summary>
    /// Indicates whether parity or CRC algorithms, ECC or other mechanisms are used. Details on the algorithm can also be supplied.
    /// </summary>
    public new string? ErrorMethodology => (string)ManagementObject[nameof(ErrorMethodology)];
    /// <summary>
    /// Array of octets that hold additional error information. An example is Error Checking and Correcting (ECC) Syndrome, or the return of the check bits if a CRC-based error methodology is used. In the latter case, if a single-bit error is recognized and the CRC algorithm is known, the exact bit that failed can be determined. This type of data (ECC Syndrome, check-bit or parity-bit data, or other vendor supplied information) is included in this field. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public byte[]? AdditionalErrorData => (byte[])ManagementObject[nameof(AdditionalErrorData)];
    /// <summary>
    /// If TRUE, the most recent error was correctable. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public bool? CorrectableError => (bool?)ManagementObject[nameof(CorrectableError)];
    /// <summary>
    /// Ending address referenced by an application or operating system and mapped by a memory controller for this memory object. The ending address is specified in kilobytes.
    /// </summary>
    public ulong? EndingAddress => (ulong?)ManagementObject[nameof(EndingAddress)];
    /// <summary>
    /// Memory access operation that caused the last error. The type of error is described by the ErrorInfo property. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public ushort? ErrorAccess => (ushort?)ManagementObject[nameof(ErrorAccess)];
    /// <summary>
    /// Address of the last memory error. The type of error is described by the ErrorInfo property. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public ulong? ErrorAddress => (ulong?)ManagementObject[nameof(ErrorAddress)];
    /// <summary>
    /// Data captured during the last erroneous memory access. The data occupies the first n octets of the array that are necessary to hold the number of bits specified by the ErrorTransferSize property. If ErrorTransferSize is 0, then this property has no meaning.
    /// </summary>
    public byte[]? ErrorData => (byte[])ManagementObject[nameof(ErrorData)];
    /// <summary>
    /// Order of data stored in the ErrorData property. If ErrorTransferSize is 0, then this property has no meaning.
    /// </summary>
    public ushort? ErrorDataOrder => (ushort?)ManagementObject[nameof(ErrorDataOrder)];
    /// <summary>
    /// Type of error that occurred most recently. The values 12 through 14 are undefined in the CIM schema because DMI mixes the semantics of the error type and whether it was correctable. Whether an error is correctable is indicated in the CorrectableError property.
    /// </summary>
    public ushort? ErrorInfo => (ushort?)ManagementObject[nameof(ErrorInfo)];
    /// <summary>
    /// Specifies the range, in bytes, to which the last error can be resolved. For example, if error addresses are resolved to bit 11 (that is, on a typical page basis), then errors can be resolved to 4 KB boundaries and this property is set to 4000. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public ulong? ErrorResolution => (ulong?)ManagementObject[nameof(ErrorResolution)];
    /// <summary>
    /// Date and time that the last memory error occurred. The type of error is described by the ErrorInfo property. If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public DateTimeOffset? ErrorTime => ManagementObject.GetDateTimePropertyValue(nameof(ErrorTime));
    /// <summary>
    /// Size of the data transfer, in bits, that caused the last error. A value of 0 indicates no error. If the ErrorInfo property is equal to 3 ("OK"), then this property should be set to 0.
    /// </summary>
    public uint? ErrorTransferSize => (uint?)ManagementObject[nameof(ErrorTransferSize)];
    /// <summary>
    /// Free form string that provides information if the ErrorType property is set to 1 ("Other"). If it is not set to 1, then this string has no meaning.
    /// </summary>
    public string? OtherErrorDescription => (string)ManagementObject[nameof(OtherErrorDescription)];
    /// <summary>
    /// Beginning address, referenced by an application or operating system and mapped by a memory controller, for this memory object. The starting address is specified in kilobytes.
    /// </summary>
    public ulong? StartingAddress => (ulong?)ManagementObject[nameof(StartingAddress)];
    /// <summary>
    /// Indicates whether the address information in the ErrorAddress property is a system-level address (TRUE) or a physical address (FALSE). If the ErrorInfo property is equal to 3 ("OK"), then this property has no meaning.
    /// </summary>
    public bool? SystemLevelAddress => (bool?)ManagementObject[nameof(SystemLevelAddress)];
}
