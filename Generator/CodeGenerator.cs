using System.Text;
using System.Threading.Channels;
namespace System.Management.Generator;

public class CodeGenerator(ChannelReader<ClassDefinition> channel)
{
    private static readonly HashSet<string> _excludedFolders = new(StringComparer.OrdinalIgnoreCase) { "bin", "obj" };

    private readonly DirectoryInfo _targetDirectory = FindTypesDirectory();
    private readonly Dictionary<string, ClassDefinition> _classDefinitions = new(StringComparer.OrdinalIgnoreCase);

    public async Task GenerateCode()
    {
        var existingFiles = _targetDirectory.GetDirectories().Where(d => !_excludedFolders.Contains(d.Name)).SelectMany(d => d.GetFiles("*.g.cs", SearchOption.AllDirectories)).Select(fi => fi.FullName).ToHashSet(StringComparer.OrdinalIgnoreCase);
        await foreach (var typeDefinition in channel.ReadAllAsync())
        {
            _classDefinitions[typeDefinition.ClassName] = typeDefinition;
            Console.WriteLine($"Generating class for {typeDefinition.ClassName}.");
            (var namespaceName, var className) = ParseClassName(typeDefinition.ClassName);

            var superClass = GetRelativeClassName(typeDefinition.SuperClass, namespaceName);
            var properties = typeDefinition.Properties;
            var methods = typeDefinition.Methods;

            var inheritedPropertes = GetInheritedPropertiesFrom(typeDefinition.SuperClass).ToList();
            var inheritedMethods = GetInheritedMethodsFrom(typeDefinition.SuperClass).ToList();
            if (typeDefinition.SuperClass != null)
            {
                if (inheritedPropertes.Count != 0)
                {
                    properties = properties.Except(inheritedPropertes).ToList();
                }

                if (inheritedMethods.Count != 0)
                {
                    methods = methods.Except(inheritedMethods).ToList();
                }
            }

            var classCode = GenerateClassCode(namespaceName, className, superClass, properties, methods, inheritedPropertes, inheritedMethods);
            var fileInfo = new FileInfo(Path.Combine(_targetDirectory.FullName, namespaceName, $"{className}.g.cs"));
            if (fileInfo.Directory!.Exists)
            {
                existingFiles.Remove(fileInfo.FullName);
            }
            else
            {
                fileInfo.Directory.Create();
            }
            Console.WriteLine($"Writing => {fileInfo.FullName}");
            try
            {
                File.WriteAllText(fileInfo.FullName, classCode);
            }
            catch (Exception ex)
            {
                ErrorReporter.Report($"Unable to write file: {ex.Message}", ex);
            }
        }

        foreach (var oldFile in existingFiles)
        {
            if (File.Exists(oldFile))
            {
                Console.WriteLine($"Deleting old file => {oldFile}");
                try
                {
                    File.Delete(oldFile);
                }
                catch (Exception ex)
                {
                    ErrorReporter.Report($"Unable to delete file: {ex.Message}", ex);
                }
            }
        }
    }

    private static DirectoryInfo FindTypesDirectory()
    {
        var dir = new DirectoryInfo(Environment.CurrentDirectory);
        while (dir != null)
        {
            var typesDir = new DirectoryInfo(Path.Combine(dir.FullName, "Types"));
            if (typesDir.Exists)
                return typesDir;
            dir = dir.Parent;
        }
        throw new DirectoryNotFoundException("Could not find 'Types' directory in any parent directory.");
    }

    private IEnumerable<PropertyDefinition> GetInheritedPropertiesFrom(string? superClass)
        => superClass != null && _classDefinitions.TryGetValue(superClass, out var td) ? td.Properties.Concat(GetInheritedPropertiesFrom(td.SuperClass)) : [];

    private IEnumerable<MethodDefinition> GetInheritedMethodsFrom(string? superClass)
        => superClass != null && _classDefinitions.TryGetValue(superClass, out var td) ? td.Methods.Concat(GetInheritedMethodsFrom(td.SuperClass)) : [];

    private string GenerateClassCode(string namespaceName, string className, string superClass, List<PropertyDefinition> properties, List<MethodDefinition> methods, List<PropertyDefinition> inheritedPropertes, List<MethodDefinition> inheritedMethods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
            /**************************************************************
             *                                                            *
             *   WARNING: This file is autogenerated by                   *
             *   System.Management.Generator.                             *
             *   Any changes made to this file will be overwritten.       *
             *                                                            *
             **************************************************************/
            """);
        sb.AppendLine($"namespace System.Management.Types.{namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial record class {className}(ManagementObject ManagementObject) : {superClass}(ManagementObject)");
        sb.AppendLine("{");

        properties.ForEach(p => GenerateProperty(sb, p, inheritedPropertes.Any(ip => ip.Name.Equals(p.Name)), namespaceName));

        methods.ForEach(m => GenerateMethod(sb, m, inheritedMethods.Any(im => Match(m, im)), namespaceName));

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static bool Match(MethodDefinition method, MethodDefinition inheritedMethod)
        => method.Name.Equals(inheritedMethod.Name) && false;

    private void GenerateProperty(StringBuilder sb, PropertyDefinition property, bool hidesInherited, string namespaceName)
    {
        if (!string.IsNullOrWhiteSpace(property.Description))
        {
            sb.AppendLine("    /// <summary>");
            foreach (var line in property.Description.Split(['\n', '\r'], options: StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
            {
                sb.Append("    /// ");
                sb.AppendLine(line);
            }
            sb.AppendLine("    /// </summary>");
        }
        sb.Append("    public ");
        if (hidesInherited)
        {
            sb.Append("new ");
        }
        sb.Append(GetPrintableType(property, namespaceName));
        if (property.IsArray)
        {
            sb.Append("[]");
        }
        sb.Append("? ");
        sb.Append(property.Name);
        sb.Append(" => ");
        if (property.Type == CimType.DateTime)
        {
            if (property.IsArray)
            {
                sb.Append("ManagementObject.GetDateTimePropertyValues(nameof(");
            }
            else
            {
                sb.Append("ManagementObject.GetDateTimePropertyValue(nameof(");
            }
            sb.Append(property.Name);
            sb.Append("))");
        }
        else
        {
            sb.Append('(');
            sb.Append(GetPrintableType(property, namespaceName));
            if (property.IsArray)
            {
                sb.Append("[]");
            }
            if (IsStruct(property))
            {
                sb.Append('?');
            }
            sb.Append(")ManagementObject[nameof(");
            sb.Append(property.Name);
            sb.Append(")]");
        }
        sb.AppendLine(";");
    }

    private void GenerateMethod(StringBuilder sb, MethodDefinition method, bool hidesInherited, string namespaceName)
    {
        sb.Append("    public ");
        if (hidesInherited)
        {
            sb.Append("new ");
        }
        sb.Append("Task<");
        sb.Append(GetPrintableType(method.ReturnType));
        sb.Append("> ");
        sb.Append(method.Name);

        sb.Append('(');
        var first = true;
        foreach (var parameter in method.Parameters)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            sb.Append(GetPrintableType(parameter, namespaceName));
            if (parameter.IsArray)
            {
                sb.Append("[]?");
            }
            else if (IsStruct(parameter))
            {
                sb.Append('?');
            }

            sb.Append(' ');
            sb.Append(parameter.Name);
            first = false;
        }
        sb.AppendLine(")");

        sb.Append("    => ManagementObject.InvokeMethod(nameof(");
        sb.Append(method.Name);
        sb.AppendLine("),");

        sb.Append("        [");
        first = true;
        foreach (var parameter in method.Parameters)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            sb.Append(parameter.Name);
            first = false;
        }
        sb.AppendLine("],");

        sb.Append("        [");
        first = true;
        foreach (var parameter in method.Parameters)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            sb.Append("nameof(");
            sb.Append(parameter.Name);
            sb.Append(')');
            first = false;
        }
        sb.AppendLine("]);");
    }

    private (string namespaceName, string className) ParseClassName(string? className)
    {
        if (string.IsNullOrEmpty(className))
        {
            className = "__Object";
        }
        else
        {
            className = _classDefinitions[className].ClassName;
        }

        if (className[0] == '_')
        {
            return ("Base", className[1..]);
        }

        var splitIndex = className.IndexOf('_');
        if (char.IsNumber(className[splitIndex + 1]))
        {
            return (className[..splitIndex], className[splitIndex..]);
        }

        return (className[..splitIndex], className[(splitIndex + 1)..]);
    }

    private string GetRelativeClassName(string? referenceType, string currentNamespaceName)
    {
        (var namespaceName, var className) = ParseClassName(referenceType);
        return namespaceName == currentNamespaceName ? className : $"{namespaceName}.{className}";
    }

    private string GetPrintableType(PropertyDefinition property, string currentNamespaceName)
        => property.Type switch
        {
            CimType.Reference => GetRelativeClassName(property.ReferencedClass, currentNamespaceName),
            _ => GetPrintableType(property.Type)
        };


    private static string GetPrintableType(CimType type)
        => type switch
        {
            CimType.SInt16 => "short",
            CimType.SInt32 => "int",
            CimType.Real32 => "float",
            CimType.Real64 => "double",
            CimType.String => "string",
            CimType.Boolean => "bool",
            CimType.Object => "object",
            CimType.SInt8 => "sbyte",
            CimType.UInt8 => "byte",
            CimType.UInt16 => "ushort",
            CimType.UInt32 => "uint",
            CimType.SInt64 => "long",
            CimType.UInt64 => "ulong",
            CimType.DateTime => "DateTimeOffset",
            CimType.Char16 => "char",
            _ => throw new NotSupportedException()
        };

    private static bool IsReferenceType(PropertyDefinition property)
        => property.IsArray || property.Type switch
        {
            CimType.String => true,
            CimType.Object => true,
            CimType.Reference => true,
            _ => false
        };
    private static bool IsStruct(PropertyDefinition property)
        => !IsReferenceType(property);
}